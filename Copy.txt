import axios from 'axios';
 
export const APPLY_LEAVE_REQUEST = 'APPLY_LEAVE_REQUEST';
export const APPLY_LEAVE_SUCCESS = 'APPLY_LEAVE_SUCCESS';
export const APPLY_LEAVE_FAILURE = 'APPLY_LEAVE_FAILURE';
export const FETCH_PENDING_LEAVES_REQUEST = 'FETCH_PENDING_LEAVES_REQUEST';
export const FETCH_PENDING_LEAVES_SUCCESS = 'FETCH_PENDING_LEAVES_SUCCESS';
export const FETCH_PENDING_LEAVES_FAILURE = 'FETCH_PENDING_LEAVES_FAILURE';
export const FETCH_LEAVES_REQUEST = 'FETCH_LEAVES_REQUEST';
export const FETCH_LEAVES_SUCCESS = 'FETCH_LEAVES_SUCCESS';
export const FETCH_LEAVES_FAILURE = 'FETCH_LEAVES_FAILURE';
export const FETCH_HISTORY_REQUEST = 'FETCH_HISTORY_REQUEST';
export const FETCH_HISTORY_SUCCESS = 'FETCH_HISTORY_SUCCESS';
export const FETCH_HISTORY_FAILURE = 'FETCH_HISTORY_FAILURE';
export const CANCEL_LEAVE_REQUEST = 'CANCEL_LEAVE_REQUEST';
export const CANCEL_LEAVE_SUCCESS = 'CANCEL_LEAVE_SUCCESS';
export const CANCEL_LEAVE_FAILURE = 'CANCEL_LEAVE_FAILURE';
export const APPROVE_LEAVE_REQUEST = 'APPROVE_LEAVE_REQUEST';
export const APPROVE_LEAVE_SUCCESS = 'APPROVE_LEAVE_SUCCESS';
export const APPROVE_LEAVE_FAILURE = 'APPROVE_LEAVE_FAILURE';
export const DECLINE_LEAVE_REQUEST = 'DECLINE_LEAVE_REQUEST';
export const DECLINE_LEAVE_SUCCESS = 'DECLINE_LEAVE_SUCCESS';
export const DECLINE_LEAVE_FAILURE = 'DECLINE_LEAVE_FAILURE';
export const FETCH_APPLIED_LEAVES_BY_DATE_RANGE_REQUEST = 'FETCH_APPLIED_LEAVES_BY_DATE_RANGE_REQUEST';
export const FETCH_APPLIED_LEAVES_BY_DATE_RANGE_SUCCESS = 'FETCH_APPLIED_LEAVES_BY_DATE_RANGE_SUCCESS';
export const FETCH_APPLIED_LEAVES_BY_DATE_RANGE_FAILURE = 'FETCH_APPLIED_LEAVES_BY_DATE_RANGE_FAILURE';
 
export const applyLeave = (leaveData, token) => async dispatch => {
  dispatch({ type: APPLY_LEAVE_REQUEST });
  try {
    const response = await axios.post('http://localhost:5000/api/leaves/apply', leaveData, {
      headers: { Authorization: `Bearer ${token}` },
    });
    dispatch({ type: APPLY_LEAVE_SUCCESS, payload: response.data });
  } catch (error) {
    const message = error.response?.data?.errors?.[0] || 'Failed to apply leave';
    dispatch({ type: APPLY_LEAVE_FAILURE, payload: message });
    throw error;
  }
};
 
export const fetchPendingLeaves = (token, page = 0, size = 10) => async dispatch => {
  dispatch({ type: FETCH_PENDING_LEAVES_REQUEST });
  try {
    const response = await axios.get('http://localhost:5000/api/leaves/pending', {
      params: { page, size },
      headers: { Authorization: `Bearer ${token}` },
    });
    dispatch({ type: FETCH_PENDING_LEAVES_SUCCESS, payload: response.data.content });
  } catch (error) {
    const message = error.response?.data?.errors?.[0] ||'Failed to fetch pending leaves';
    dispatch({ type: FETCH_PENDING_LEAVES_FAILURE, payload: message });
    throw error;
  }
};
 
export const fetchCurrentLeaves = (token, page = 0, size = 10) => async dispatch => {
  dispatch({ type: FETCH_LEAVES_REQUEST });
  try {
    const response = await axios.get('http://localhost:5000/api/leaves/current', {
      params: { page, size },
      headers: { Authorization: `Bearer ${token}` },
    });
    dispatch({ type: FETCH_LEAVES_SUCCESS, payload: response.data.content });
  } catch (error) {
    const message = error.response?.data?.errors?.[0] ||'Failed to fetch leaves';
    dispatch({ type: FETCH_LEAVES_FAILURE, payload: message });
    throw error;
  }
};
 
export const fetchLeaveHistory = (token, year, page = 0, size = 10) => async dispatch => {
  dispatch({ type: FETCH_HISTORY_REQUEST });
  try {
    const response = await axios.get('http://localhost:5000/api/leaves/history', {
      params: { year, page, size },
      headers: { Authorization: `Bearer ${token}` },
    });
    dispatch({ type: FETCH_HISTORY_SUCCESS, payload: response.data });
  } catch (error) {
    const message = error.response?.data?.error || error.message || 'Failed to fetch history';
    dispatch({ type: FETCH_HISTORY_FAILURE, payload: message });
    throw error;
  }
};
 
export const cancelLeave = (leaveId, token) => async dispatch => {
  dispatch({ type: CANCEL_LEAVE_REQUEST });
  try {
    await axios.delete(`http://localhost:5000/api/leaves/${leaveId}`, {
      headers: { Authorization: `Bearer ${token}` },
    });
    dispatch({ type: CANCEL_LEAVE_SUCCESS, payload: leaveId });
  } catch (error) {
    const message = error.response?.data?.errors?.[0] ||'Failed to cancel leave';
    dispatch({ type: CANCEL_LEAVE_FAILURE, payload: message });
    throw error;
  }
};
 
export const approveLeave = (leaveId, token) => async dispatch => {
  dispatch({ type: APPROVE_LEAVE_REQUEST });
  try {
    await axios.put(`http://localhost:5000/api/leaves/approve/${leaveId}`, null, {
      headers: { Authorization: `Bearer ${token}` },
    });
    dispatch({ type: APPROVE_LEAVE_SUCCESS, payload: { id: leaveId } });
    dispatch(fetchPendingLeaves(token));
  } catch (error) {
    const message = error.response?.data?.errors?.[0] || 'Failed to approve leave';
    dispatch({ type: APPROVE_LEAVE_FAILURE, payload: message });
    dispatch(fetchPendingLeaves(token));
    throw error;
  }
};
 
export const declineLeave = (leaveId, reason, token) => async dispatch => {
  dispatch({ type: DECLINE_LEAVE_REQUEST });
  try {
    await axios.put(`http://localhost:5000/api/leaves/reject/${leaveId}`, { declineReason: reason }, {
      headers: { Authorization: `Bearer ${token}` },
    });
    dispatch({ type: DECLINE_LEAVE_SUCCESS, payload: { id: leaveId } });
    dispatch(fetchPendingLeaves(token));
  } catch (error) {
    const message = error.response?.data?.errors?.[0] || error.response?.data?.message ||'Failed to decline leave';
    dispatch({ type: DECLINE_LEAVE_FAILURE, payload: message });
    dispatch(fetchPendingLeaves(token));
    throw error;
  }
};
 
export const fetchAppliedLeavesByDateRange = (startDate, endDate, token) => async dispatch => {
  dispatch({ type: FETCH_APPLIED_LEAVES_BY_DATE_RANGE_REQUEST });
  try {
    const response = await axios.get('http://localhost:5000/api/leaves/applied', {
      params: { startDate, endDate },
      headers: { Authorization: `Bearer ${token}` },
    });
   
    dispatch({ type: FETCH_APPLIED_LEAVES_BY_DATE_RANGE_SUCCESS, payload: response.data });
  } catch (error) {
    const message = error.response?.data?.errors?.[0] ||'Failed to fetch applied leaves';
    dispatch({ type: FETCH_APPLIED_LEAVES_BY_DATE_RANGE_FAILURE, payload: message });
    throw error;
  }
};const asyncHandler = require('express-async-handler');

const axios = require('axios');

const constants = require('../utils/constants');

const env = require('../config/env');

const { handleAxiosError } = require('../utils/errorHandler');

const CustomError = require('../utils/customError');
 
const applyLeave = asyncHandler(async (req, res) => {

  const { employeeEmail, startDate, endDate, reason } = req.body;

  try {

    const response = await axios.post(`${env.SPRING_BOOT_API}/api/leaves/apply`, {

      employeeEmail,

      startDate,

      endDate,

      reason,

    }, {

      headers: { Authorization: req.headers.authorization },

    });

    res.status(constants.status.CREATED).json(response.data);

  } catch (error) {

    handleAxiosError(error, res);

  }

});
 
const getCurrentLeaves = asyncHandler(async (req, res) => {

  const {employeeEmail,page,size} = req.query;

  console.log('Request is comng')

  console.log(req.query)

  try{

    const response = await axios.get(`${env.SPRING_BOOT_API}/api/leaves/current`, {

      params: {employeeEmail,page, size},

      headers: { Authorization: req.headers.authorization },

    });

    res.status(constants.status.OK).json(response.data);

  } catch (error) {

    handleAxiosError(error, res);

  }

});
 
const getPendingLeaves = asyncHandler(async (req, res) => {

  const { page, size} = req.query;

  try {

    const response = await axios.get(`${env.SPRING_BOOT_API}/api/leaves/pending`, {

      params: { page, size },

      headers: { Authorization: req.headers.authorization },

    });

    res.status(constants.status.OK).json(response.data);

  } catch (error) {

    handleAxiosError(error, res);

  }

});

const getLeavesByDateRange = asyncHandler(async (req, res) => {

  const { startDate, endDate } = req.query;

  try {

    if (!startDate || !endDate) {

      throw new CustomError('startDate and endDate are required', constants.status.BAD_REQUEST);

    }

    const response = await axios.get(`${env.SPRING_BOOT_API}/api/leaves/applied`, {

      params: { startDate, endDate },

      headers: { Authorization: req.headers.authorization },

    });

    console.log(req.headers.authorization)

    res.status(constants.status.OK).json(response.data);

  } catch (error) {

    handleAxiosError(error, res);

  }

});
 
const approveLeave = asyncHandler(async (req, res) => {

  const { leaveId } = req.params;

  try {

    const response = await axios.put(`${env.SPRING_BOOT_API}/api/leaves/approve/${leaveId}`,null, {

      headers: { Authorization: req.headers.authorization },

    });

    res.status(200).json(response.data);

  } catch (error) {

    handleAxiosError(error, res);

  }

});
 
const rejectLeave = asyncHandler(async (req, res) => {

  const { leaveId } = req.params;

  const { declineReason } = req.body;

  try {

    const response = await axios.put(`${env.SPRING_BOOT_API}/api/leaves/reject/${leaveId}`, {

      declineReason},{headers: { Authorization: req.headers.authorization }}

    );

    res.status(constants.status.OK).json(response.data);

  } catch (error) {

    handleAxiosError(error, res);

  }

});
 
const cancelLeave = asyncHandler(async (req, res) => {

    const { id } = req.params;

    console.log(`Cancel leave request received for leaveId: ${id}`);

    console.log(`Forwarding DELETE request to Spring Boot: ${env.SPRING_BOOT_API}/api/leaves/${id}`);

    try {

        if (!id || isNaN(id) || parseInt(id) <= 0) {

            throw new CustomError('Leave ID must be a positive integer', constants.status.BAD_REQUEST);

        }

        if (!req.headers.authorization) {

            throw new CustomError('Authorization header missing', constants.status.UNAUTHORIZED);

        }

        const response = await axios.delete(`${env.SPRING_BOOT_API}/api/leaves/${id}`, {

            headers: { Authorization: req.headers.authorization },

        });

        console.log(`Spring Boot response: ${response.status}`, response.data);

        res.status(response.status).json(response.data || { message: 'Leave cancelled successfully' });

    } catch (error) {

        console.log('Error while forwarding to Spring Boot:', error.message);

        handleAxiosError(error, res);

    }

});
 
const getLeaveHistory = asyncHandler(async (req, res) => {

  const {  year, page = 0, size = 10, sortBy, direction } = req.query;

  try {

    if (!req.headers.authorization) {

      throw new CustomError('Authorization header missing', constants.status.UNAUTHORIZED);

    }

    const response = await axios.get(`${env.SPRING_BOOT_API}/api/leaves/history`, {

      params: { year, page, size, sortBy, direction }, // Added year to params

      headers: { Authorization: req.headers.authorization },

    });

    console.log(`Spring Boot response: ${response.status}`, response.data);

    res.status(constants.status.OK).json(response.data);

  } catch (error) {

    console.log('Error fetching leave history:', error.message);

    handleAxiosError(error, res);

  }

});
 
module.exports = {

  applyLeave,

  cancelLeave,

  getCurrentLeaves,

  getPendingLeaves,

  approveLeave,

  rejectLeave,

  getLeaveHistory,

  getLeavesByDateRange, // Added this

};






Leave validation error: Only admins can access all leave applications
Hibernate: select lr1_0.id,lr1_0.category,lr1_0.created_at,lr1_0.end_date,lr1_0.reason,lr1_0.start_date,lr1_0.status,lr1_0.user_id from leave_request lr1_0 limit ?,?
 
